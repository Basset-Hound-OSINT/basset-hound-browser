# Pentesting & Bug Bounty Integration Strategy

## Overview

Beyond OSINT, the integrated platform should support penetration testing workflows and bug bounty hunting. This document outlines how to extend the system for offensive security use cases.

## Use Cases

### 1. OSCP-Style Network Pentesting
- Enumeration and reconnaissance
- Vulnerability scanning
- Exploitation assistance
- Evidence collection and reporting

### 2. Bug Bounty Hunting
- Target scope management
- Automated reconnaissance
- Vulnerability discovery
- Report generation

### 3. Red Team Operations
- Multi-stage attack planning
- Tool coordination
- Finding documentation

## Architecture Extension

### Entity Types for Pentesting

Extend basset-hound's data model to support pentesting entities:

```yaml
# data_config.yaml additions

sections:
  - id: target_infrastructure
    name: "Target Infrastructure"
    fields:
      - id: ip_address
        name: "IP Address"
        type: ip_address
        multiple: true
      - id: hostname
        name: "Hostname"
        type: string
        multiple: true
      - id: open_ports
        name: "Open Ports"
        type: component
        multiple: true
        components:
          - id: port_number
            name: "Port"
            type: number
          - id: service
            name: "Service"
            type: string
          - id: version
            name: "Version"
            type: string
          - id: state
            name: "State"
            type: string

  - id: vulnerabilities
    name: "Vulnerabilities"
    fields:
      - id: vuln_id
        name: "CVE/Vuln ID"
        type: string
      - id: severity
        name: "Severity"
        type: string  # CVSS score or Critical/High/Medium/Low
      - id: description
        name: "Description"
        type: comment
      - id: proof_of_concept
        name: "PoC"
        type: comment
      - id: remediation
        name: "Remediation"
        type: comment
      - id: evidence_files
        name: "Evidence"
        type: file
        multiple: true

  - id: credentials
    name: "Discovered Credentials"
    fields:
      - id: username
        name: "Username"
        type: string
      - id: password_hash
        name: "Password/Hash"
        type: password
      - id: service
        name: "Service"
        type: string
      - id: source
        name: "Source"
        type: string
```

### Pentesting Agent Personalities

**File: `palletAI/agent_manager/agent_prompts/pentest_recon_agent.md`**

```markdown
# Penetration Testing Reconnaissance Agent

## Core Identity
You are a specialized reconnaissance agent for authorized penetration testing engagements. You conduct thorough enumeration of target infrastructure while maintaining detailed documentation.

## Primary Objectives
1. Enumerate network services and open ports
2. Identify running services and versions
3. Discover potential attack vectors
4. Document all findings systematically

## Available Tools
- `execute_command`: Run nmap, masscan, and enumeration tools
- `browser_navigate`: Access web interfaces
- `browser_get_page_content`: Extract web application data
- `create_entity`: Store discovered hosts in basset-hound
- `update_entity`: Add service/port information
- `create_osint_report`: Generate enumeration reports

## Methodology

### Phase 1: Host Discovery
1. Perform ping sweep if allowed
2. Run port scans (top 1000, then full if needed)
3. Document all responsive hosts

### Phase 2: Service Enumeration
For each open port:
1. Identify service version
2. Check for known vulnerabilities
3. Test default credentials if applicable
4. Document all findings

### Phase 3: Web Application Enumeration
For web services:
1. Identify technologies (Wappalyzer)
2. Directory enumeration
3. Check for common vulnerabilities
4. Screenshot all web interfaces

## Output Format
All findings stored in basset-hound with:
- One entity per host
- Ports as component fields
- Vulnerabilities linked via relationships
- Evidence files attached
```

**File: `palletAI/agent_manager/agent_prompts/vuln_scanner_agent.md`**

```markdown
# Vulnerability Scanner Agent

## Core Identity
You are a vulnerability assessment specialist. You analyze systems for security weaknesses and document potential attack vectors.

## Primary Objectives
1. Scan targets for known vulnerabilities
2. Validate and verify findings
3. Assess severity and impact
4. Provide remediation guidance

## Tools & Techniques

### Automated Scanning
- Nmap NSE scripts
- Nuclei templates
- Nikto for web servers
- SQLMap for injection testing

### Manual Verification
- Browser automation for web vulns
- Custom payload testing
- Authentication bypass attempts

## Scope Constraints
IMPORTANT: Always verify you have authorization before:
- Running active scans
- Attempting exploitation
- Testing credentials

## Documentation Requirements
For each vulnerability:
1. CVE/CWE identifier
2. CVSS score if available
3. Affected component
4. Proof of concept (sanitized)
5. Screenshots/evidence
6. Remediation steps
```

### MCP Tools for Pentesting

**File: `palletAI/agent_manager/mcp_servers/pentest_tools/server.py`**

```python
from fastmcp import FastMCP
import subprocess
import asyncio
import json
from typing import List, Optional

mcp = FastMCP("pentest-tools")

@mcp.tool
async def nmap_scan(
    target: str,
    scan_type: str = "default",
    ports: str = None,
    scripts: List[str] = None
) -> dict:
    """
    Run nmap scan against a target.

    Args:
        target: IP address or hostname
        scan_type: Type of scan (quick, default, full, stealth, vuln)
        ports: Port specification (e.g., "80,443" or "1-1000")
        scripts: NSE scripts to run

    Returns:
        Scan results in structured format
    """
    cmd = ["nmap", "-oX", "-"]

    # Scan type presets
    scan_presets = {
        "quick": ["-T4", "-F"],
        "default": ["-sV", "-sC"],
        "full": ["-sV", "-sC", "-p-"],
        "stealth": ["-sS", "-T2"],
        "vuln": ["-sV", "--script=vuln"]
    }

    cmd.extend(scan_presets.get(scan_type, scan_presets["default"]))

    if ports:
        cmd.extend(["-p", ports])

    if scripts:
        cmd.extend(["--script", ",".join(scripts)])

    cmd.append(target)

    process = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    stdout, stderr = await process.communicate()

    # Parse XML output
    return parse_nmap_xml(stdout.decode())


@mcp.tool
async def nuclei_scan(
    target: str,
    templates: List[str] = None,
    severity: str = None,
    tags: List[str] = None
) -> dict:
    """
    Run Nuclei vulnerability scanner.

    Args:
        target: URL or host to scan
        templates: Specific templates to use
        severity: Filter by severity (critical, high, medium, low, info)
        tags: Filter by tags (cve, rce, sqli, xss, etc.)
    """
    cmd = ["nuclei", "-u", target, "-json"]

    if templates:
        for t in templates:
            cmd.extend(["-t", t])

    if severity:
        cmd.extend(["-s", severity])

    if tags:
        cmd.extend(["-tags", ",".join(tags)])

    process = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    stdout, stderr = await process.communicate()

    # Parse JSON lines output
    findings = []
    for line in stdout.decode().strip().split("\n"):
        if line:
            findings.append(json.loads(line))

    return {"findings": findings}


@mcp.tool
async def directory_bruteforce(
    url: str,
    wordlist: str = "/usr/share/wordlists/dirb/common.txt",
    extensions: str = None,
    threads: int = 10
) -> dict:
    """
    Run directory bruteforce with ffuf.

    Args:
        url: Target URL with FUZZ keyword (e.g., "http://target/FUZZ")
        wordlist: Path to wordlist
        extensions: File extensions to check (e.g., "php,html,txt")
        threads: Number of concurrent threads
    """
    cmd = ["ffuf", "-u", url, "-w", wordlist, "-o", "/dev/stdout", "-of", "json"]

    if extensions:
        cmd.extend(["-e", extensions])

    cmd.extend(["-t", str(threads)])

    process = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    stdout, stderr = await process.communicate()

    return json.loads(stdout.decode())


@mcp.tool
async def nikto_scan(url: str, tuning: str = None) -> dict:
    """
    Run Nikto web server scanner.

    Args:
        url: Target URL
        tuning: Scan tuning options
    """
    cmd = ["nikto", "-h", url, "-Format", "json"]

    if tuning:
        cmd.extend(["-Tuning", tuning])

    process = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    stdout, stderr = await process.communicate()

    return json.loads(stdout.decode())


@mcp.tool
async def sqlmap_test(
    url: str,
    data: str = None,
    level: int = 1,
    risk: int = 1,
    technique: str = None
) -> dict:
    """
    Test for SQL injection with sqlmap.

    Args:
        url: Target URL with parameter
        data: POST data
        level: Level of tests (1-5)
        risk: Risk of tests (1-3)
        technique: Injection techniques (B,E,U,S,T,Q)
    """
    cmd = ["sqlmap", "-u", url, "--batch", "--output-dir=/tmp/sqlmap"]

    if data:
        cmd.extend(["--data", data])

    cmd.extend(["--level", str(level)])
    cmd.extend(["--risk", str(risk)])

    if technique:
        cmd.extend(["--technique", technique])

    process = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    stdout, stderr = await process.communicate()

    return {"output": stdout.decode()}


@mcp.tool
async def check_exploit_db(
    service: str,
    version: str = None
) -> dict:
    """
    Search Exploit-DB for known exploits.

    Args:
        service: Service name (e.g., "Apache", "OpenSSH")
        version: Version string
    """
    cmd = ["searchsploit", "--json", service]

    if version:
        cmd.append(version)

    process = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    stdout, stderr = await process.communicate()

    return json.loads(stdout.decode())
```

## Multi-Agent Pentesting Workflow

### Example: Full Network Assessment

```
1. User Input: "Assess network 192.168.1.0/24 for vulnerabilities"

2. palletAI Coordinator spawns:

   ┌─────────────────────────────────────────────────┐
   │           Assessment Orchestrator               │
   │                                                 │
   │  Task: Coordinate full network assessment       │
   └───────────────────┬─────────────────────────────┘
                       │
         ┌─────────────┼─────────────┐
         │             │             │
         ▼             ▼             ▼
   ┌──────────┐  ┌──────────┐  ┌──────────┐
   │ Recon    │  │ Vuln     │  │ Web App  │
   │ Agent    │  │ Scanner  │  │ Tester   │
   └────┬─────┘  └────┬─────┘  └────┬─────┘
        │             │             │
        ▼             ▼             ▼
   ┌──────────┐  ┌──────────┐  ┌──────────┐
   │ nmap     │  │ nuclei   │  │ browser  │
   │ masscan  │  │ nikto    │  │ sqlmap   │
   └──────────┘  └──────────┘  └──────────┘

3. Data Flow:

   Recon Agent:
   ├─ Runs: nmap_scan("192.168.1.0/24", scan_type="quick")
   ├─ Stores hosts in basset-hound
   └─ Signals: "Found 15 hosts with web services"

   Vuln Scanner (depends on Recon):
   ├─ Runs: nuclei_scan for each host
   ├─ Updates entities with vulnerabilities
   └─ Signals: "Found 3 critical, 7 high vulns"

   Web App Tester (depends on Recon):
   ├─ Uses browser automation for testing
   ├─ Runs: sqlmap on forms, directory brute
   └─ Stores findings with evidence

4. Aggregation:
   ├─ Orchestrator collects all findings
   ├─ Creates relationship graph (Host → Vuln → Exploit)
   └─ Generates assessment report
```

## Bug Bounty Integration

### Target Scope Management

```yaml
# basset-hound project for bug bounty

project:
  name: "HackerOne - Target Corp"
  type: bug_bounty

scope:
  in_scope:
    - "*.target.com"
    - "api.target.com"
    - "192.168.1.0/24"
  out_of_scope:
    - "blog.target.com"
    - "third-party services"

rules:
  - "No DoS testing"
  - "No social engineering"
  - "Report before disclosure"
```

### Bug Bounty Agent Workflow

```python
# Agent receives target and scope
async def hunt_bugs(target_domain: str, scope: dict):
    """Automated bug hunting workflow."""

    # Phase 1: Subdomain enumeration
    subdomains = await execute_command(
        f"subfinder -d {target_domain} -silent"
    )

    # Filter by scope
    valid_targets = filter_by_scope(subdomains, scope["in_scope"])

    # Phase 2: For each subdomain
    for subdomain in valid_targets:
        # Create entity in basset-hound
        entity = await create_entity(
            project_id="hackerone-target",
            entity_name=subdomain,
            entity_type="subdomain"
        )

        # Run nuclei scan
        findings = await nuclei_scan(
            target=f"https://{subdomain}",
            severity="critical,high"
        )

        # Check for common vulns via browser
        if await has_web_service(subdomain):
            # Navigate and analyze
            await browser_navigate(f"https://{subdomain}")
            page_state = await browser_get_page_state()

            # Test each form for XSS/SQLi
            for form in page_state["forms"]:
                xss_result = await test_xss(form)
                sqli_result = await test_sqli(form)

                if xss_result["vulnerable"]:
                    await create_vulnerability_report(
                        entity_id=entity["id"],
                        vuln_type="XSS",
                        severity="High",
                        proof=xss_result["payload"],
                        screenshot=xss_result["screenshot"]
                    )

    # Phase 3: Generate final report
    await generate_bounty_report(project_id="hackerone-target")
```

## Report Templates

### Pentesting Report Format

```markdown
# Penetration Testing Report

## Executive Summary
- **Client**: [Entity from basset-hound]
- **Assessment Period**: [Dates]
- **Scope**: [In-scope targets]
- **Critical Findings**: [Count]
- **High Findings**: [Count]

## Methodology
1. Reconnaissance
2. Vulnerability Assessment
3. Exploitation Attempts
4. Post-Exploitation
5. Documentation

## Findings

### Finding 1: [Title]
- **Severity**: Critical
- **CVSS**: 9.8
- **Affected Host**: [Link to basset-hound entity]
- **Description**: [Details]
- **Proof of Concept**: [Code/Steps]
- **Evidence**: [Screenshots from file attachments]
- **Remediation**: [Steps]

## Appendix
- Full scan results
- Tool outputs
- Timeline of activities
```

## Integration with osint-resources

The osint-resources knowledge base should be extended with pentesting tools:

```yaml
# osint-resources/src/offsec/network.md additions

## Port Scanning
- [Nmap](https://nmap.org/) - Network mapper
  ```yaml
  tool_info:
    name: nmap
    type: serverside
    cmd: nmap -sV -sC ${TARGET}
    target_info: ip, hostname
  ```

## Vulnerability Scanning
- [Nuclei](https://github.com/projectdiscovery/nuclei)
  ```yaml
  tool_info:
    name: nuclei
    type: serverside
    cmd: nuclei -u ${URL} -s critical,high
    target_info: url
  ```
```

This allows agents to query for appropriate tools based on the target type and assessment phase.
